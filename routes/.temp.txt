
----------------------------------------------
----------------------------------------------
----------------------------------------------
for (let i=1; i<10; i++){
	for (let j=1; j<10; j++){
		for (let n =1; n<10;n++){
		if  
		}
	}
}





<script>

/* A Backtracking program in
Javascript to solve Sudoku problem */

function isUnique(minor, row, col, num){
	
	// Row has the unique (row-clash)
	for(let c = 0; c < minor.length; c++)	{
		if  minor[row][c] == num)
		{
			return false;
		}
	}

	// Column has the unique numbers (column-clash)
	for(let r = 0; r < minor.length; r++)
	{
		if  minor[r][col] == num)
		{
			return false;
		}
	}

	// Corresponding square has
	// unique number (box-clash)
	let sqrt = Math.floor(Math.sqrt minor.length));
	let boxRowStart = row - row % sqrt;
	let boxColStart = col - col % sqrt;

	for(let r = boxRowStart;
			r < boxRowStart + sqrt; r++)
	{
		for(let d = boxColStart;
				d < boxColStart + sqrt; d++)
		{
			if  minor[r][d] == num)
			{
				return false;
			}
		}
	}

	// If there is no clash, it's safe
	return true;
}

function solveSudoku (minor, n)
{
	let row = -1;
	let col = -1;
	let isEmpty = true;
	for(let i = 0; i < n; i++)
	{
		for(let j = 0; j < n; j++)
		{
			if  minor[i][j] == 0)
			{
				row = i;
				col = j;

				// We still have some remaining
				// missing values in Sudoku
				isEmpty = false;
				break;
			}
		}
		if (!isEmpty)
		{
			break;
		}
	}

	// No empty space left
	if (isEmpty)
	{
		return true;
	}

	// Else for each-row backtrack
	for(let num = 1; num <= n; num++)
	{
		if (isSafe (minor, row, col, num))
		{
		 minor[row][col] = num;
			if (solveSudoku (minor, n))
			{
				
				// print minor, n);
				return true;
			}
			else
			{
				
				// Replace it
			 minor[row][col] = 0;
			}
		}
	}
	return false;
}

function print (minor, N)
{
	
	// We got the answer, just print it
	for(let r = 0; r < N; r++)
	{
		for(let d = 0; d < N; d++)
		{
			document.write minor[r][d]);
			document.write(" ");
		}
		document.write("<br>");

		if ((r + 1) % Math.floor(Math.sqrt(N)) == 0)
		{
			document.write("");
		}
	}
}

// Driver Code
let minor = [ [ 3, 0, 6, 5, 0, 8, 4, 0, 0 ],
			[ 5, 2, 0, 0, 0, 0, 0, 0, 0 ],
			[ 0, 8, 7, 0, 0, 0, 0, 3, 1 ],
			[ 0, 0, 3, 0, 1, 0, 0, 8, 0 ],
			[ 9, 0, 0, 8, 6, 3, 0, 0, 5 ],
			[ 0, 5, 0, 0, 9, 0, 6, 0, 0 ],
			[ 1, 3, 0, 0, 0, 0, 2, 5, 0 ],
			[ 0, 0, 0, 0, 0, 0, 0, 7, 4 ],
			[ 0, 0, 5, 2, 0, 6, 3, 0, 0 ] ];
		
let N = minor.length;

if (solveSudoku (minor, N))
{
	
	// Print solution
	print (minor, N);
}
else
{
	document.write("No solution");
}

// This code is contributed by avanitrachhadiya2155

</script>
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------

<script>

const N = 9

// Bitmasks for each row/column/box
let row = new Array(N), col = new Array(N), box = new Array(N);
let seted = false;

// Utility function to find the box index
// of an element at position [i][j] in the grid
function getBox(i,j)
{
	return Math.floor(i / 3) * 3 + Math.floor(j / 3);
}

// Utility function to check if a number
// is present in the coresponding row/column/box
function isSafe(i,j,number)
{
	return !((row[i] >> number) & 1)
		&& !((col[j] >> number) & 1)
		&& !((box[getBox(i,j)] >> number) & 1);
}

// Utility function to set the initial values of a Sudoku minor
// (map the values in the bitmasks)
function setInitialValues(grid)
{
	for (let i = 0; i < N;i++)
		for (let j = 0; j < N; j++)
				row[i] |= 1 << grid[i][j],
				col[j] |= 1 << grid[i][j],
				box[getBox(i, j)] |= 1 << grid[i][j];
}

/* Takes a partially filled-in grid and attempts
to assign values to all unassigned locations in
such a way to meet the requirements for
Sudoku solution (non-duplication across rows,
columns, and boxes) */
function SolveSudoku(grid ,i, j)
{
	// Set the initial values
	if(!seted){
		seted = true,
		setInitialValues(grid);
	}

	if(i == N - 1 && j == N)
		return true;
	if(j == N){
		j = 0;
		i++;
	}

	if(grid[i][j])
		return SolveSudoku(grid, i, j + 1);

	for (let nr = 1; nr <= N;nr++)
	{
		if(isSafe(i, j, nr))
		{
			/* Assign nr in the
				current (i, j)
				position and
				add nr to each bitmask
			*/
			grid[i][j] = nr;
			row[i] |= 1 << nr;
			col[j] |= 1 << nr;
			box[getBox(i, j)] |= 1 << nr;

			if(SolveSudoku(grid, i,j + 1))
				return true;

			// Remove nr from each bitmask
			// and search for another possibility
			row[i] &= ~(1 << nr);
			col[j] &= ~(1 << nr);
			box[getBox(i, j)] &= ~(1 << nr);
		}

		grid[i][j] = 0;
	}

	return false;
}

// Utility function to print the solved grid
function print(grid)
{
	for (let i = 0; i < N; i++){
		for (let j = 0; j < N; j++){
			document.write(grid[i][j]," ");
		}
		document.write("</br>");
	}
}

// Driver Code

	// 0 means unassigned cells
	let grid = [ [ 3, 0, 6, 5, 0, 8, 4, 0, 0 ],
					[ 5, 2, 0, 0, 0, 0, 0, 0, 0 ],
					[ 0, 8, 7, 0, 0, 0, 0, 3, 1 ],
					[ 0, 0, 3, 0, 1, 0, 0, 8, 0 ],
					[ 9, 0, 0, 8, 6, 3, 0, 0, 5 ],
					[ 0, 5, 0, 0, 9, 0, 6, 0, 0 ],
					[ 1, 3, 0, 0, 0, 0, 2, 5, 0 ],
					[ 0, 0, 0, 0, 0, 0, 0, 7, 4 ],
					[ 0, 0, 5, 2, 0, 6, 3, 0, 0 ]];

	if (SolveSudoku(grid,0 ,0))
		print(grid);
	else
		document.write("No solution exists","</br>");

// This code is contributed by shinjanpatra

</script>


All puzzle logic can go into /controllers/sudoku-solver.js
The validate function should take a given puzzle string and check it to see if it has 81 valid characters for the input.
The check functions should be validating against the current state of the board.
The solve function should handle solving any given valid puzzle string, not just the test inputs and solutions. You are expected to write out the logic to solve this.
All routing logic can go into /routes/api.js
See the puzzle-strings.js file in /controllers for some sample puzzles your application should solve
To run the challenge tests on this page, set NODE_ENV to test without quotes in the .env file
To run the tests in the console, use the command npm run test. To open the Replit console, press Ctrl+Shift+P (Cmd if on a Mac) and type "open shell"
Write the following tests in tests/1_unit-tests.js:

Logic handles a valid puzzle string of 81 characters
Logic handles a puzzle string with invalid characters (not 1-9 or .)
Logic handles a puzzle string that is not 81 characters in length
Logic handles a valid row placement
Logic handles an invalid row placement
Logic handles a valid column placement
Logic handles an invalid column placement
Logic handles a valid region (3x3 grid) placement
Logic handles an invalid region (3x3 grid) placement
Valid puzzle strings pass the solver
Invalid puzzle strings fail the solver
Solver returns the expected solution for an incomplete puzzle
Write the following tests in tests/2_functional-tests.js

Solve a puzzle with valid puzzle string: POST request to /api/solve
Solve a puzzle with missing puzzle string: POST request to /api/solve
Solve a puzzle with invalid characters: POST request to /api/solve
Solve a puzzle with incorrect length: POST request to /api/solve
Solve a puzzle that cannot be solved: POST request to /api/solve
Check a puzzle placement with all fields: POST request to /api/check
Check a puzzle placement with single placement conflict: POST request to /api/check
Check a puzzle placement with multiple placement conflicts: POST request to /api/check
Check a puzzle placement with all placement conflicts: POST request to /api/check
Check a puzzle placement with missing required fields: POST request to /api/check
Check a puzzle placement with invalid characters: POST request to /api/check
Check a puzzle placement with incorrect length: POST request to /api/check
Check a puzzle placement with invalid placement coordinate: POST request to /api/check
Check a puzzle placement with invalid placement value: POST request to /api/check



Tests
Waiting:You should provide your own project, not the example URL.
Waiting:You can POST /api/solve with form data containing puzzle 
		which will be a string containing a combination of numbers (1-9) and periods . 
		to represent empty spaces. The returned object will contain a solution property with the solved puzzle.
Waiting:If the object submitted to /api/solve is missing puzzle, the returned value will be { error: 'Required field missing' }
Waiting:If the puzzle submitted to /api/solve contains values which are not numbers or periods, 
		the returned value will be { error: 'Invalid characters in puzzle' }
Waiting:If the puzzle submitted to /api/solve is greater or less than 81 characters, 
		the returned value will be { error: 'Expected puzzle to be 81 characters long' }
Waiting:If the puzzle submitted to /api/solve is invalid or cannot be solved, the returned value will be { error: 'Puzzle cannot be solved' }
Waiting:You can POST to /api/check an object containing puzzle, coordinate, 
		and value where the coordinate is the letter A-I indicating the row, 
		followed by a number 1-9 indicating the column, and value is a number from 1-9.
Waiting:The return value from the POST to /api/check will be an object containing a valid property, 
		which is true if the number may be placed at the provided coordinate and false if the number may not. 
		If false, the returned object will also contain a conflict property which is an array containing the strings "row", "column", and/or "region" depending on which makes the placement invalid.
Waiting:If value submitted to /api/check is already placed in puzzle on that coordinate, 
		the returned value will be an object containing a valid property with true if value is not conflicting.
Waiting:If the puzzle submitted to /api/check contains values which are not numbers or periods, 
		the returned value will be { error: 'Invalid characters in puzzle' }
Waiting:If the puzzle submitted to /api/check is greater or less than 81 characters, 
		the returned value will be { error: 'Expected puzzle to be 81 characters long' }
Waiting:If the object submitted to /api/check is missing puzzle, coordinate or value, 
		the returned value will be { error: 'Required field(s) missing' }
Waiting:If the coordinate submitted to api/check does not point to an existing grid cell, the returned value will be { error: 'Invalid coordinate'}
Waiting:If the value submitted to /api/check is not a number between 1 and 9, the returned value will be { error: 'Invalid value' }
Waiting:All 12 unit tests are complete and passing. See /tests/1_unit-tests.js for the expected behavior you should write tests for.
Waiting:All 14 functional tests are complete and passing. See /tests/2_functional-tests.js for the expected functionality you should write tests for.




